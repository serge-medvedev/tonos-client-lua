# Lua bindings to TON SDK's Core Client Library

## Why Lua?
- Nginx and Apache HTTP Server can use Lua for configuration
- HAProxy can be extended using Lua
- Redis uses Lua for its "stored procedures"
- In science,  [Foldit](https://fold.it) uses Lua for user scripts
- In game development, Lua is the most popular scripting language...
- ... and [more](https://en.wikipedia.org/wiki/List_of_applications_using_Lua)

These are opportunities for a great many possible use cases.

## Features

The main feature of this bindings library is a generator-like representation of asynchronous processes.
The motivation was to avoid callback hell by hiding a few low-level tricks behind a synchronous constructs such as Lua's generic __for__ loop.

For example, when we need to monitor all the events (callback calls) initiated by `processing.process_message`, we write the following code:

```lua
for request_id, params_json, response_type, finished
    in processing.process_message(context, params) do

    local response = json.decode(params_json)

    -- work with decoded response

    if response_type == 1 then
        -- handle error if any
    end

    if finished then
        -- do something special at the end of a stream
    end
end
```

On the contrary, if we're willing to ignore events generated by the request and just want it to do the job, we might do this:

```lua
processing.process_message(context, params).await()
```

Under the hood it uses coroutines, being initiated and resumed on the Lua-side and yielding on the C-side when new data is received via callback function. When all the events are fetched on the Lua-side, request-related data is automatically and safely dropped on the C-side.

## Testing

There are four groups of tests:
- fast & slow
- free & paid

All __fast__ tests are __free__ and all __paid__ tests are __slow__.

By __paid__ tests I mean those which require account funding, e.g. for successful contract deployment.
To run those, you have to:
- have a wallet on the [DevNet](https://net.ton.dev) with some tokens in it
- create a file called _funding_wallet.lua_ under the _test_ directory based on [funding_wallet.lua.example](test/funding_wallet.lua.example)

Then you can run __paid__ tests like this:
```shell
$ luarocks test -- --pattern='.+_spec.lua' --run=paid .
```

All the __free__ tests are run automatically as a Docker image build step.

TODO

- negative tests (to check error messages?)
